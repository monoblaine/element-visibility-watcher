{"version":3,"file":"ElementVisibilityWatcher.js","sources":["../src/visibility.observer.js","../src/ractive.viewport.event.js"],"sourcesContent":["class ElementVisibilityWatcher {\r\n  constructor (observerOptions = {}) {\r\n    this.observerOptions = Object.assign({\r\n      root: null,\r\n      rootMargin: '0px',\r\n      threshold: 0.01\r\n    }, observerOptions)\r\n    this.visibleElementsStack = []\r\n    this.observingElements = []\r\n    this.observingElementsCallbacks = []\r\n    this.initialize()\r\n  }\r\n  triggerCallbacks (cameIn, goneOut) {\r\n    let observingElements = this.observingElements\r\n    let observingElementsCallbacks = this.observingElementsCallbacks\r\n\r\n    let cameInElements = cameIn.map((entry) => { return entry.target })\r\n    let goneOutElements = goneOut.map((entry) => { return entry.target })\r\n\r\n    observingElements.forEach((element, idx) => {\r\n      let arg\r\n      let entry\r\n      let cameInElementsIdx = cameInElements.indexOf(element)\r\n      let goneOutElementsIdx = goneOutElements.indexOf(element)\r\n\r\n      if (cameInElementsIdx > -1) {\r\n        arg = true\r\n        entry = cameIn[cameInElementsIdx]\r\n      }\r\n      if (goneOutElementsIdx > -1) {\r\n        arg = false\r\n        entry = cameIn[goneOutElementsIdx]\r\n      }\r\n      if (arg !== undefined) {\r\n        observingElementsCallbacks[idx](arg, entry)\r\n      }\r\n    })\r\n  }\r\n  observerCallback (entries) {\r\n    let goneOut = []\r\n    let cameIn = []\r\n    entries.forEach((entry) => {\r\n      let target = entry.target\r\n      let idx = this.visibleElementsStack.indexOf(target)\r\n      let isIntersecting = entry.isIntersecting\r\n      if (!isIntersecting) {\r\n        if (idx > -1) {\r\n          goneOut.push(entry)\r\n          this.visibleElementsStack.splice(idx, 1)\r\n        }\r\n      } else {\r\n        if (idx === -1) {\r\n          cameIn.push(entry)\r\n          this.visibleElementsStack.push(entry.target)\r\n        }\r\n      }\r\n    })\r\n    this.triggerCallbacks(cameIn, goneOut)\r\n  }\r\n  initialize () {\r\n    let cb = this.observerCallback.bind(this)\r\n    this.visibilityObserver = new window.IntersectionObserver(cb, this.observerOptions)\r\n  }\r\n  watch (element, callback) {\r\n    if (element && callback) {\r\n      this.observingElements.push(element)\r\n      this.observingElementsCallbacks.push(callback)\r\n      this.visibilityObserver.observe(element)\r\n    }\r\n  }\r\n  unwatch (element) {\r\n    let idx = this.observingElements.indexOf(element)\r\n    if (idx > -1) {\r\n      this.observingElements.splice(idx, 1)\r\n      this.observingElementsCallbacks.splice(idx, 1)\r\n    }\r\n  }\r\n}\r\n\r\nexport default ElementVisibilityWatcher\r\n","import ElementVisibilityWatcher from './visibility.observer'\r\n\r\nif (window.Ractive) {\r\n  window.Ractive.creteViewportEvent = typeof window.IntersectionObserver !== 'undefined'\r\n    ? (opts) => {\r\n      let visibilityObserver = new ElementVisibilityWatcher(opts)\r\n\r\n      return (node, fire) => {\r\n        visibilityObserver.watch(node, (visible, data) => {\r\n          fire({\r\n            node: node,\r\n            original: {\r\n              visible: visible,\r\n              intersectionData: data\r\n            }\r\n          })\r\n        })\r\n        return {\r\n          teardown: () => {\r\n            visibilityObserver.unwatch(node)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    : (opts) => (node, fire) => ({ teardown: () => {} })\r\n}\r\n"],"names":["ElementVisibilityWatcher","observerOptions","this","Object","assign","root","rootMargin","threshold","visibleElementsStack","observingElements","observingElementsCallbacks","initialize","triggerCallbacks","cameIn","goneOut","let","cameInElements","map","entry","target","goneOutElements","forEach","element","idx","arg","cameInElementsIdx","indexOf","goneOutElementsIdx","undefined","observerCallback","entries","isIntersecting","push","this$1","splice","cb","bind","visibilityObserver","window","IntersectionObserver","watch","callback","observe","unwatch","Ractive","creteViewportEvent","opts","node","fire","visible","data","original","intersectionData","teardown"],"mappings":";;;;;;;;qDAAA,IAAMA,EACJ,SAAaC,kBAAkB,IAC7BC,KAAKD,gBAAkBE,OAAOC,OAAO,CACrCC,KAAQ,KACRC,WAAc,MACdC,UAAa,KACVN,GACHC,KAAKM,qBAAuB,GAC5BN,KAAKO,kBAAoB,GACzBP,KAAKQ,2BAA6B,GACpCR,KAAOS,qBAETX,YAAEY,0BAAkBC,EAAQC,GACxBC,IAAIN,EAAoBP,KAAKO,kBACzBC,EAA6BR,KAAKQ,2BAElCM,EAAiBH,EAAOI,aAAKC,GAAY,OAAOA,EAAMC,SACtDC,EAAkBN,EAAQG,aAAKC,GAAY,OAAOA,EAAMC,SAE9DV,EAAoBY,iBAASC,EAASC,GACpC,IAAMC,EACAN,EACAO,EAAoBT,EAAeU,QAAQJ,GAC3CK,EAAqBP,EAAgBM,QAAQJ,IAExB,EAArBG,IACJD,GAAQ,EACNN,EAAQL,EAAOY,KAES,EAAtBE,IACJH,GAAQ,EACNN,EAAQL,EAAOc,SAELC,IAARJ,GACJd,EAA6Ba,GAAKC,EAAKN,MAI7ClB,YAAE6B,0BAAkBC,cACZhB,EAAU,GACVD,EAAS,GACbiB,EAAQT,iBAASH,GACfH,IAAII,EAASD,EAAMC,OACfI,EAAMrB,EAAKM,qBAAqBkB,QAAQP,GACvBD,EAAMa,gBAOZ,IAATR,IACFV,EAAOmB,KAAKd,GACde,EAAOzB,qBAAqBwB,KAAKd,EAAMC,UAP5B,EAAPI,IACFT,EAAQkB,KAAKd,GACfe,EAAOzB,qBAAqB0B,OAAOX,EAAK,MAS5CrB,KAAKU,iBAAiBC,EAAQC,IAElCd,YAAEW,sBACA,IAAMwB,EAAKjC,KAAK2B,iBAAiBO,KAAKlC,MACpCA,KAAKmC,mBAAqB,IAAIC,OAAOC,qBAAqBJ,EAAIjC,KAAKD,kBAEvED,YAAEwC,eAAOlB,EAASmB,GACVnB,GAAWmB,IACbvC,KAAKO,kBAAkBuB,KAAKV,GAC5BpB,KAAKQ,2BAA2BsB,KAAKS,GACrCvC,KAAKmC,mBAAmBK,QAAQpB,KAGtCtB,YAAE2C,iBAASrB,GACT,IAAMC,EAAMrB,KAAKO,kBAAkBiB,QAAQJ,IAC9B,EAAPC,IACJrB,KAAOO,kBAAkByB,OAAOX,EAAK,GACrCrB,KAAOQ,2BAA2BwB,OAAOX,EAAK,KCxE9Ce,OAAOM,UACTN,OAAOM,QAAQC,wBAA4D,IAAhCP,OAAOC,8BAC7CO,GACD/B,IAAIsB,EAAqB,IAAIrC,EAAyB8C,GAEtD,gBAAQC,EAAMC,GAUZ,OATAX,EAAmBG,MAAMO,WAAOE,EAASC,GACvCF,EAAK,CACHD,KAAMA,EACNI,SAAU,CACRF,QAASA,EACTG,iBAAkBF,OAIjB,CACLG,oBACEhB,EAAmBM,QAAQI,gBAKhCD,mBAAUC,EAAMC,UAAYK"}